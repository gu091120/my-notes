
## 内存分类
查看内存情况
```
console.log(process.memoryUsage())
/*
    { rss: 21635072, //进程中内存（单位b）
    heapTotal: 7708672, //v8 已申请内存
    heapUsed: 4270416,  //v8 已使用
    external: 8224 } 
*/
```
`v8`主要分为堆外内存和堆内内存（新生代和老生代）
```
//堆外内存
var showMen = function() {
    var men = process.memoryUsage();
    var format = function(bytes) {
        return (bytes / 1024 / 1024).toFixed(2) + "MB";
    };
    console.log(
        `heapToal:${format(men.heapTotal)},heapUsed:${format(
            men.heapUsed
        )},rss:${format(men.rss)}`
    );
    console.log("-----------------------------------------------------------");
};

var useMen = function() {
    var size = 20 * 1024 * 1024;
    var arr = Buffer.alloc(size);
    arr.forEach(i => (arr[i] = 0));
    return arr;
};

var total = [];

function run() {
    for (let i = 0; i < 5; i++) {
        showMen();
        total.push(useMen());
    }
}

run();

/*
    heapToal:10.35MB,heapUsed:4.96MB,rss:25.10MB
    -----------------------------------------------------------
    heapToal:10.35MB,heapUsed:5.01MB,rss:46.39MB
    -----------------------------------------------------------
    heapToal:10.35MB,heapUsed:5.07MB,rss:66.49MB
    -----------------------------------------------------------
    heapToal:10.35MB,heapUsed:5.08MB,rss:86.50MB
    -----------------------------------------------------------
    heapToal:10.35MB,heapUsed:5.09MB,rss:106.52MB
    -----------------------------------------------------------
*/

```
改写 `var arr = Buffer.alloc(size);` => `var arr = new Array(size)`
```
/*
    heapToal:7.35MB,heapUsed:4.08MB,rss:20.36MB
    -----------------------------------------------------------
    heapToal:167.36MB,heapUsed:164.11MB,rss:180.45MB
    -----------------------------------------------------------
    heapToal:327.38MB,heapUsed:324.12MB,rss:340.46MB
    -----------------------------------------------------------
    heapToal:487.39MB,heapUsed:484.12MB,rss:500.51MB
    -----------------------------------------------------------
    heapToal:647.40MB,heapUsed:644.12MB,rss:660.55MB
    -----------------------------------------------------------
*/
```
可以很明显的看出，在使用的`Buffer`对象的时候，申请过来的内存是`v8`以外的

### 堆内内存
#### 新生代内存
占内存的小部分
##### 内存回收
内存的回收机制采用的是`scavenge`机制：主要就是将新生代内存分为两份，将正在使用的设为`from`,在回收的时候将存活的内存复制到另一个`to`内存块，并将`from`内存清空，设为 `to`内存，而原来的`to`内存变为`from`内存块，这样做的优点就是，速度快，没有碎片内存，缺点就是只能利用内存的一半
##### 新生代内存的晋升
在从 `from` 到 `to`内存块的时候，有两种晋升为老生代：
- 在`from`内存块中占有超过25%，也就是占有内存较大的时候
- 已经经历过一次内存回收的内存块

#### 老生代内存
占内存的大部分
##### 内存回收
采用了两种回收机制：
- Mark-Sweep：
首先在遍历对象的时候对存活对象做标记，然后在清理阶段对内存中未标记的内存几种清理。这里就存在一个内存碎片问题，因为一块内存中被清理后，就会出现部分内存被回收，一部分确是存活的，所以造成内存的浪费。与`scavenge`相比最大的优点就是内存的使用比较高，但是速度相对就比较慢一点了，而且会产生碎片内存

- Mark-Compact
在 `Mark-Sweep`基础上演变而来，主要区别在于，在标记完成，会多一步将内存进行重新排序，将存活的存放在一起，将死亡的存在一起，等到清理阶段就可以清理出没有碎片的内存了。但是由于多了排序这个步骤，就会比`Mark-Sweep`速度回慢一些，优点就是没有碎片。

##### 内存回收优化
`v8`在虽然老生代内存中组合两种策略，但是由于每一次回收内存需要暂停逻辑执行，以至于集中处理标记和清理就会影响逻辑执行，所以 `v8`采用的分多个小步穿插在逻辑执行中，这样停顿就会减少道原来的1/6左右。
### 堆外内存
`Buffer`并不属于`V8`分配，而是通过底层`C++`直接申请的，所以就没有受`v8`内存的限制，这样就为`node`提供操作大内存能力


## 使用内存注意点
- 不要将内存做缓存，由于node可使用内存非常有限，所以尽量不要用内存做缓存
- 尽量少定义全局变量，由于全局变量只有在程序结束时才会被回收，所以会一直占有内存。
- 由于数组（队列），可以解决很多问题，所以使用的场景比较多，但是会存在一些问题：比如，一个日志系统，如果日志的产生远远比写入快的多，这样就很可能造成内存溢出。


## 内存限制
`v8`的可用内存默认最高（64位：1.4G，32位：0.7G），限制内存使用主要原因是内存回收机制，`v8`做一次小的内存回收需要50毫秒，所以如果内存过大就会影响整体内存的回收